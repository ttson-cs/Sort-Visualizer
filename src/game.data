#ifndef TIM_SORT_H
#define TIM_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class TimSort : public SortStrategy {
  public:
    TimSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Tim Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        timSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Tim Sort");
    }

  private:
    auto timSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        if (end - start < 15) {
            insertionSort(v, start, end);
            return;
        }
        auto mid{(start + end) / 2};
        timSort(v, start, mid);
        timSort(v, mid + 1, end);
        if (v[mid].first > v[mid + 1].first) {
            merge(v, start, mid, end);
        }
    }

    auto insertionSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{start + 1}; i != end + 1; ++i) {
            auto [barHeight, color] = v[i];
            auto j{i};
            while (j > start && v[j - 1].first > barHeight) {
                Visualize::visualizeTraverse(v, j, j - 1, "Tim Sort");
                v[j] = v[j - 1];
                --j;
            }
            Visualize::visualizeTraverse(v, j, i, "Tim Sort");
            v[j] = std::make_pair(barHeight, color);
        }
    }

    auto merge(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int mid, int end) -> void {
        std::vector<std::pair<int, std::pair<float, Color>>> temp(end - start + 1);
        auto i{start};
        auto j{mid + 1};
        auto k{0};
        while (i <= mid && j <= end) {
            Visualize::visualizeTraverse(v, i, j, "Tim Sort");
            if (v[i].first < v[j].first) {
                temp[k++] = v[i++];
            } else {
                temp[k++] = v[j++];
            }
        }
        while (i <= mid) {
            Visualize::visualizeTraverse(v, i, j, "Tim Sort");
            temp[k++] = v[i++];
        }
        while (j <= end) {
            Visualize::visualizeTraverse(v, i, j, "Tim Sort");
            temp[k++] = v[j++];
        }
        for (auto i{0}; i != temp.size(); ++i) {
            v[start + i] = temp[i];
        }
    }
};

#endif#ifndef INSERTION_SORT_H
#define INSERTION_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class InsertionSort : public SortStrategy {
  public:
    InsertionSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Insertion Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        insertionSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Insertion Sort");
    }

  private:
    auto insertionSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{start + 1}; i != end + 1; ++i) {
            auto [barHeight, color] = v[i];
            auto j{i};
            while (j > 0 && v[j - 1].first > barHeight) {
                Visualize::visualizeTraverse(v, j - 1, j, "Insertion Sort");
                v[j] = v[j - 1];
                --j;
            }
            Visualize::visualizeTraverse(v, j, i, "Insertion Sort");
            v[j] = std::make_pair(barHeight, color);
        }
    }
};

#endif#ifndef SHELL_SORT_H
#define SHELL_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class ShellSort : public SortStrategy {
  public:
    ShellSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Shell Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        shellSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Shell Sort");
    }

  private:
    auto shellSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto gap{end + 1 / 2}; gap != start; gap /= 2) {
            for (auto i{gap}; i != end + 1; ++i) {
                auto j{i};
                while (j >= gap && v[j].first < v[j - gap].first) {
                    Visualize::visualizeTraverse(v, j, j - gap, "Shell Sort");
                    std::swap(v[j], v[j - gap]);
                    j -= gap;
                }
            }
        }
    }
};

#endif#ifndef BINARY_INSERTION_SORT_H
#define BINARY_INSERTION_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class BinaryInsertionSort : public SortStrategy {
  public:
    BinaryInsertionSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Binary Insertion Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        binaryInsertionSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Binary Insertion Sort");
    }

  private:
    auto binaryInsertionSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{start + 1}; i != end + 1; ++i) {
            auto key{v[i]};
            auto low{start};
            auto high{i - 1};
            while (low <= high) {
                auto mid{(low + high) / 2};
                if (v[mid].first < key.first) {
                    Visualize::visualizeTraverse(v, low, mid + 1, "Binary Insertion Sort");
                    low = mid + 1;
                } else {
                    Visualize::visualizeTraverse(v, high, mid - 1, "Binary Insertion Sort");
                    high = mid - 1;
                }
            }
            for (auto j{i - 1}; j != low - 1; --j) {
                Visualize::visualizeTraverse(v, j + 1, j, "Binary Insertion Sort");
                v[j + 1] = v[j];
            }
            Visualize::visualizeTraverse(v, low, i, "Binary Insertion Sort");
            v[low] = key;
        }
    }
};

#endif#ifndef BITONIC_SORT_H
#define BITONIC_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class BitonicSort : public SortStrategy {
  public:
    BitonicSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Bitonic Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        bitonicSort(v, 0, v.size(), true);
        Visualize::visualizeEnding(v, "Bitonic Sort");
    }

  private:
    auto bitonicSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int size, bool ascending) -> void {
        if (size > 1) {
            auto k{size / 2};
            bitonicSort(v, start, k, !ascending);
            bitonicSort(v, start + k, size - k, ascending);
            bitonicMerge(v, start, size, ascending);
        }
    };

    auto bitonicMerge(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int size, bool ascending) -> void {
        if (size > 1) {
            auto k{greatestPowerOfTwoLessThan(size)};
            for (auto i{start}; i != start + size - k; ++i) {
                Visualize::visualizeTraverse(v, i, i + k, "Bitonic Sort");
                if (ascending == (v[i].first > v[i + k].first)) {
                    std::swap(v[i], v[i + k]);
                }
            }
            bitonicMerge(v, start, k, ascending);
            bitonicMerge(v, start + k, size - k, ascending);
        }
    };

    int greatestPowerOfTwoLessThan(int n) {
        auto k{1};
        while (k < n) {
            k *= 2;
        }
        return k / 2;
    }
};

#endif#ifndef RADIX_SORT_H
#define RADIX_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class RadixSort : public SortStrategy {
  public:
    RadixSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Radix Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        radixSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Radix Sort");
    }

  private:
    auto radixSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        if (start < end) {
            auto max{v[start].first};
            auto j{start};
            for (auto i{start + 1}; i != end; ++i) {
                if (v[i].first > max) {
                    Visualize::visualizeTraverse(v, i, j, "Radix Sort");
                    max = v[i].first;
                    j   = i;
                }
            }
            auto exp{1};
            while (max / exp > 0) {
                countingSort(v, start, end, exp);
                exp *= 10;
            }
        }
    }

    auto countingSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end, int exp) -> void {
        std::vector<std::pair<int, std::pair<float, Color>>> temp(end - start + 1);
        std::vector<int> count(10);
        for (auto i{start}; i != end + 1; ++i) {
            ++count[(v[i].first / exp) % 10];
        }
        for (auto i{1}; i != 10; ++i) {
            Visualize::visualizeTraverse(v, i, i - 1, "Radix Sort");
            count[i] += count[i - 1];
        }
        for (auto i{end}; i != start - 1; --i) {
            auto j{(v[i].first / exp) % 10};
            Visualize::visualizeTraverse(v, i, count[j] - 1, "Radix Sort");
            temp[count[j] - 1] = v[i];
            --count[j];
        }
        for (auto i{start}; i != end + 1; ++i) {
            Visualize::visualizeTraverse(v, i, i - start, "Radix Sort");
            v[i] = temp[i - start];
        }
    }
};
#endif#ifndef PIGEONHOLE_SORT_H
#define PIGEONHOLE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class PigeonholeSort : public SortStrategy {
  public:
    PigeonholeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Pigeonhole Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        countingSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Pigeonhole Sort");
    }

  private:
    auto countingSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        auto min{v[start].first};
        auto max{v[start].first};
        for (auto i{start + 1}; i != end + 1; ++i) {
            if (v[i].first < min) {
                min = v[i].first;
            }
            if (v[i].first > max) {
                max = v[i].first;
            }
        }
        auto range{max - min + 1};
        auto buckets{std::vector<std::vector<std::pair<int, std::pair<float, Color>>>>(range)};
        for (auto i{start}; i != end + 1; ++i) {
            Visualize::visualizeTraverse(v, i, v[i].first - min, "Pigeonhole Sort");
            auto index{v[i].first - min};
            buckets[index].push_back(v[i]);
        }
        auto index{0};
        for (auto i{0}; i != range; ++i) {
            if (buckets[i].size() > 0) {
                for (auto j{0}; j != buckets[i].size(); ++j) {
                    Visualize::visualizeTraverse(v, index, buckets[i][j].first, "Pigeonhole Sort");
                    v[index] = buckets[i][j];
                    ++index;
                }
            }
        }
    }
};

#endif#ifndef MERGE_SORT_H
#define MERGE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class MergeSort : public SortStrategy {
  public:
    MergeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Merge Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        mergeSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Merge Sort");
    }

  private:
    auto mergeSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end)-> void {
        if (start < end) {
            auto mid{(start + end) / 2};
            mergeSort(v, start, mid);
            mergeSort(v, mid + 1, end);
            merge(v, start, mid, end);
        }
    }

    auto merge(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int mid, int end)-> void {
        std::vector<std::pair<int, std::pair<float, Color>>> temp(end - start + 1);
        auto i{start};
        auto j{mid + 1};
        auto k{0};
        while (i <= mid && j <= end) {
            Visualize::visualizeTraverse(v, i, j, "Merge Sort");
            if (v[i].first < v[j].first) {
                temp[k++] = v[i++];
            } else {
                temp[k++] = v[j++];
            }
        }
        while (i <= mid) {
            Visualize::visualizeTraverse(v, i, j, "Merge Sort");
            temp[k++] = v[i++];
        }
        while (j <= end) {
            Visualize::visualizeTraverse(v, i, j, "Merge Sort");
            temp[k++] = v[j++];
        }
        auto size{temp.size()};
        for (auto i{0}; i != size; ++i) {
            v[start + i] = temp[i];
        }
    }
};

#endif#ifndef HEAP_SORT_H
#define HEAP_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class HeapSort : public SortStrategy {
  public:
    HeapSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Heap Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        heapSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Heap Sort");
    }

  private:
    auto heapSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        buildMaxHeap(v);
        for (auto i{end}; i != start; --i) {
            Visualize::visualizeTraverse(v, 0, i, "Heap Sort");
            std::swap(v[0], v[i]);
            auto j{0};
            while (j * 2 + 1 < i) {
                auto index{j * 2 + 1};
                if (index + 1 < i && v[index].first < v[index + 1].first) {
                    ++index;
                }
                if (v[j].first >= v[index].first) {
                    break;
                }
                Visualize::visualizeTraverse(v, j, index, "Heap Sort");
                std::swap(v[j], v[index]);
                j = index;
            }
        }
    }
    auto buildMaxHeap(std::vector<std::pair<int, std::pair<float, Color>>> &v) -> void {
        auto size{v.size()};
        for (auto i{1}; i != size; ++i) {
            if (v[i].first > v[(i - 1) / 2].first) {
                auto j{i};
                while (v[j].first > v[(j - 1) / 2].first) {
                    Visualize::visualizeTraverse(v, j, (j - 1) / 2, "Heap Sort");
                    std::swap(v[j], v[(j - 1) / 2]);
                    j = (j - 1) / 2;
                }
            }
        }
    }
};

#endif#ifndef SELECTION_SORT_H
#define SELECTION_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class SelectionSort : public SortStrategy {
  public:
    SelectionSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Selection Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        selectionSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Selection Sort");
    }

  private:
    auto selectionSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{start}; i != end + 1; ++i) {
            auto minIndex{i};
            for (auto j{i + 1}; j != end + 1; ++j) {
                Visualize::visualizeTraverse(v, j, minIndex, "Selection Sort");
                if (v[j].first < v[minIndex].first) {
                    minIndex = j;
                }
            }
            Visualize::visualizeTraverse(v, i, minIndex, "Selection Sort");
            std::swap(v[i], v[minIndex]);
        }
    }
};

#endif#ifndef CYCLE_SORT_H
#define CYCLE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class CycleSort : public SortStrategy {
  public:
    CycleSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Cycle Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        cycleSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Cycle Sort");
    }

  private:
    auto cycleSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        auto rank{0};
        for (auto cycleStart{start}; cycleStart != end + 1; ++cycleStart) {
            do {
                Visualize::visualizeTraverse(v, rank, cycleStart, "Cycle Sort");
                rank = cycleStart;
                for (auto i{cycleStart + 1}; i < end + 1; ++i) {
                    if (v[i].first < v[cycleStart].first) {
                        ++rank;
                    }
                }
                if (rank == cycleStart) {
                    break;
                }
                Visualize::visualizeTraverse(v, rank, cycleStart, "Cycle Sort");
                std::swap(v[rank], v[cycleStart]);
            } while (rank != cycleStart);
        }
    }
};

#endif#ifndef SLOW_SORT_H
#define SLOW_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class SlowSort : public SortStrategy {
  public:
    SlowSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Slow Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        slowSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Slow Sort");
    }

  private:
    auto slowSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        if (start < end) {
            auto mid{(start + end) / 2};
            slowSort(v, start, mid);
            slowSort(v, mid + 1, end);
            Visualize::visualizeTraverse(v, mid, end, "Slow Sort");
            if (v[mid].first > v[end].first) {
                std::swap(v[mid], v[end]);
            }
            slowSort(v, start, end - 1);
        }
    }
};

#endif#ifndef ODD_EVEN_SORT_H
#define ODD_EVEN_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class OddEvenSort : public SortStrategy {
  public:
    OddEvenSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Odd Even Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        oddEvenSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Odd Even Sort");
    }

  private:
    auto oddEvenSort(std::vector<std::pair<int, std::pair<float,Color>>> &v, int start, int end) -> void {
        bool isSorted{false};
        while (!isSorted) {
            isSorted = true;
            for (auto i{start + 1}; i < end; i += 2) {
                Visualize::visualizeTraverse(v, i, i + 1, "Odd Even Sort");
                if (v[i].first > v[i + 1].first) {
                    std::swap(v[i], v[i + 1]);
                    isSorted = false;
                }
            }
            for (auto i{start}; i < end; i += 2) {
                Visualize::visualizeTraverse(v, i, i + 1, "Odd Even Sort");
                if (v[i].first > v[i + 1].first) {
                    std::swap(v[i], v[i + 1]);
                    isSorted = false;
                }
            }
        }
    }
};

#endif#ifndef BINARY_GNOME_SORT
#define BINARY_GNOME_SORT

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class BinaryGnomeSort : public SortStrategy {
public:
    BinaryGnomeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Binary Gnome Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        binaryGnomeSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Binary Gnome Sort");
    }

  private:
    auto binaryGnomeSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{start + 1}; i != end + 1; ++i) {
            auto key{v[i]};
            auto low{0};
            auto high{i};
            while (low < high) {
                auto mid{(low + high) / 2};
                if (v[mid].first < key.first) {
                    Visualize::visualizeTraverse(v, low, mid + 1, "Binary Gnome Sort");
                    low = mid + 1;
                } else {
                    Visualize::visualizeTraverse(v, mid, high, "Binary Gnome Sort");
                    high = mid;
                }
            }
            for (auto j{i}; j != low; --j) {
                Visualize::visualizeTraverse(v, j, j - 1, "Binary Gnome Sort");
                std::swap(v[j], v[j - 1]);
            }
        }
    }
};

#endif#ifndef QUICK_SORT_H
#define QUICK_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class QuickSort : public SortStrategy {
  public:
    QuickSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Quicksort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        quickSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Quicksort");
    }

  private:
    auto quickSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        if (start <= end) {
            auto i{start};
            auto j{end};
            auto pivot{v[(start + end) / 2]};
            while (i <= j) {
                while (v[i].first < pivot.first) {
                    ++i;
                }
                while (v[j].first > pivot.first) {
                    --j;
                }
                Visualize::visualizeTraverse(v, i, j, "Quicksort");
                if (i <= j) {
                    std::swap(v[i], v[j]);
                    ++i;
                    --j;
                }
            }
            if (start < j) {
                quickSort(v, start, j);
            }
            if (i < end) {
                quickSort(v, i, end);
            }
        }
    }

    // void quickSort(std::vector<std::pair<int, std::pair<float, Color>>> &v,
    //                int start, int end) {
    //   if (start < end) {
    //     auto pivot = partition(v, start, end);
    //     quickSort(v, start, pivot - 1);
    //     quickSort(v, pivot + 1, end);
    //   }
    // }

    // int partition(std::vector<std::pair<int, std::pair<float, Color>>> &v,
    //               int start, int end) {
    //   auto pivot = v[end];
    //   auto i = start - 1;
    //   for (auto j = start; j < end; j++) {
    //     Visualize::visualizeTraverse(v, i, j, "Quicksort");
    //     if (v[j].first <= pivot.first) {
    //       i++;
    //       std::swap(v[i], v[j]);
    //     }
    //   }
    //   Visualize::visualizeTraverse(v, i + 1, end, "Quicksort");
    //   std::swap(v[i + 1], v[end]);
    //   return i + 1;
    // }
};

#endif#ifndef COCKTAIL_SORT_H
#define COCKTAIL_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class CocktailShakerSort : public SortStrategy {
  public:
    CocktailShakerSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Cocktail Shaker Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        cocktailShakerSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Cocktail Shaker Sort");
    }

  private:
    auto cocktailShakerSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        auto size{end - start + 1};
        bool swapped{true};
        while (swapped) {
            swapped = false;
            for (auto i{start}; i != size - 1; ++i) {
                Visualize::visualizeTraverse(v, i, i + 1, "Cocktail Shaker Sort");
                if (v[i].first > v[i + 1].first) {
                    std::swap(v[i], v[i + 1]);
                    swapped = true;
                }
            }
            if (!swapped) {
                break;
            }
            swapped = false;
            for (auto i{size - 1}; i != 0; --i) {
                Visualize::visualizeTraverse(v, i, i - 1, "Cocktail Shaker Sort");
                if (v[i].first < v[i - 1].first) {
                    std::swap(v[i], v[i - 1]);
                    swapped = true;
                }
            }
        }
    }
};

#endif#ifndef GNOME_SORT_H
#define GNOME_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class GnomeSort : public SortStrategy {
  public:
    GnomeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Gnome Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        gnomeSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Gnome Sort");
    }

  private:
    auto gnomeSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        auto index{start};
        while (index != end + 1) {
            Visualize::visualizeTraverse(v, index, index - 1, "Gnome Sort");
            if (index == 0 || v[index].first >= v[index - 1].first) {
                ++index;
            } else {
                std::swap(v[index], v[index - 1]);
                --index;
            }
        }
    }
};

#endif#ifndef COMB_SORT_H
#define COMB_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class CombSort : public SortStrategy {
  public:
    CombSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Comb Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        combSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Comb Sort");
    }

  private:
    auto combSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        auto gap{end - start};
        auto size{end - start + 1};
        bool swapped{true};
        while (gap > 1 || swapped) {
            if (gap > 1) {
                gap = gap * 10 / 13;
            }
            swapped = false;
            for (auto i{start}; i != size - gap; ++i) {
                Visualize::visualizeTraverse(v, i, i + gap, "Comb Sort");
                if (v[i].first > v[i + gap].first) {
                    std::swap(v[i], v[i + gap]);
                    swapped = true;
                }
            }
        }
    }
};

#endif#ifndef BUBBLE_SORT_H
#define BUBBLE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class BubbleSort : public SortStrategy {
  public:
    BubbleSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Bubble Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        bubbleSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Bubble Sort");
    }

  private:
    auto bubbleSort(std::vector<std::pair<int, std::pair<float,Color>>> &v, int start, int end) -> void {
        for (auto i{start}; i < end; ++i) {
            for (auto j{start}; j < end - i; ++j) {
                Visualize::visualizeTraverse(v, j, j + 1, "Bubble Sort");
                if (v[j].first > v[j + 1].first) {
                    std::swap(v[j], v[j + 1]);
                }
            }
        }
    }
};

#endif#ifndef STOOGE_SORT_H
#define STOOGE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class StoogeSort : public SortStrategy {
  public:
    StoogeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Stooge Sort");
    }

    auto sort() -> void override {
        auto v{Vector::getVector()};
        stoogeSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Stooge Sort");
    }

  private:
    auto stoogeSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        if (start <= end) {
            if (v[start].first > v[end].first) {
                Visualize::visualizeTraverse(v, start, end, "Stooge Sort");
                std::swap(v[start], v[end]);
            }
            if (end - start + 1 > 2) {
                auto mid{(end - start + 1) / 3};
                stoogeSort(v, start, end - mid);
                stoogeSort(v, start + mid, end);
                stoogeSort(v, start, end - mid);
            }
        }
    }
};

#endif#ifndef PANCAKE_SORT_H
#define PANCAKE_SORT_H

#include "../../sortStrategy.h"
#include "../../vector.h"
#include "../../visualize.h"

class PancakeSort : public SortStrategy {
  public:
    PancakeSort() {
        Visualize::visualizeVector(Vector::getVector());
        Visualize::visualizeTitle("Pancake Sort");
    }

    auto sort()-> void override {
        auto v{Vector::getVector()};
        pancakeSort(v, 0, v.size() - 1);
        Visualize::visualizeEnding(v, "Pancake Sort");
    }

  private:
    auto pancakeSort(std::vector<std::pair<int, std::pair<float, Color>>> &v, int start, int end) -> void {
        for (auto i{end + 1}; i != start + 1; --i) {
            auto location{maxIndex(v, i)};
            if (location != i - 1) {
                reverseElement(v, location);
                reverseElement(v, i - 1);
            }
        }
    }

    auto maxIndex(std::vector<std::pair<int, std::pair<float, Color>>> const &v, int size) -> int {
        auto maxIndex{0};
        for (auto i{0}; i != size; ++i) {
            Visualize::visualizeTraverse(v, maxIndex, i, "Pancake Sort");
            if (v[i].first > v[maxIndex].first) {
                maxIndex = i;
            }
        }
        return maxIndex;
    }

    auto reverseElement(std::vector<std::pair<int, std::pair<float, Color>>> &v, int index) -> void {
        auto start{0};
        while (start < index) {
            Visualize::visualizeTraverse(v, start, index, "Pancake Sort");
            std::swap(v[start], v[index]);
            ++start;
            --index;
        }
    }
};

#endif